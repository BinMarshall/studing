package behavior.strategy;

/**
 * 策略模式优点：
 * 1、策略算法可以相互、自由替换
 * 2、避免多重条件判断
 * 3、扩展性好，增加一个策略非常容易
 * 策略模式缺点：
 * 1、随着策略增多，策略类也会增多，不好管理
 * 2、所有策略类都需要对外暴露。上层模块必须知道有哪些策略类，这与迪米
 *    特法则相违背，不过可以借助工厂方法模式、代理模式、享元模式来解决
 * 策略模式使用场景：
 * 1、多个类只有在算法或行为上稍有不同的场景
 * 2、算法需要自由切换的场景
 * 3、需要屏蔽算法的场景
 * 策略模式最佳实践：策略模式单独使用的场景较少，因为它有致命缺陷：所有
 *    策略都需要暴露出去，一般情况下它会结合工厂方法模式对策略进行管理
 */
/**
 * 策略模式和命令模式：
 * 1、策略模式和命令模式的类图很相似，只是命令模式多了一个接收者的角色。
 * 2、两者区别：
 * 1）意图不同
 *    策略模式的意图是封装算法，它认为算法已经是一个完整的、不可拆分的原子业务，
 *    即其意图是让这些算法独立，并且可以相互替换。而命令模式则是对动作的解耦，
 *    把一个动作的执行分为执行对象、执行命令，让两者相互独立而不互相影响
 * 2）关注点不同
 *    策略模式关注的是算法替换问题，即算法的完整性和封装性，只有具备了这两个条件
 *    才能保证其可以自由切换；而命令模式关注的是解耦问题，如何让请求者和执行者
 *    解耦是它首先需要解决的，解耦的要求就是把请求的内容封装成一个个命令，由接收
 *    者执行，由于封装成了命令，就可以同时对命令执行多种操作，如撤销、记录等
 * 3）角色功能不同
 *    策略模式中的抽象算法和具体算法与命令模式的接收者非常相似，但是他们的职责不同，
 *    策略模式中的具体算法是负责一个完整的算法逻辑，它是不可再拆分的原子业务单元，
 *    一旦变更就是对算法整体的变更。而命令模式关注命令的实现，接收者变更只影响到命令
 *    族的变更，对请求者没有任何影响，所以接收者对命令负责，而与请求者无关。
 * 4）使用场景不同
 *    策略模式适用于算法要求变换的场景，而命令模式适用于解耦两个有紧密耦合关系的对象场合
 */
/**
 * 策略模式和状态模式区别：
 * 1、环境角色的职责不同
 *    两者都有一个Context角色， 策略模式的Context只是一个委托作用，负责算法的替换；而状态模式
 *    的Context不仅仅是委托，还具有状态变化登记的作用，与具体的状态类协作，共同完成状态变化时
 *    切换行为的目的
 * 2、解决问题的重点不同
 *    策略模式意在解决内部算法如何替换的问题，即将内部算法的改变对外界的影响降到最小；而状态模式
 *    意在解决内部状态的改变而引起行为改变的问题，它的出发点是事物状态，封装状态而暴露行为，一个
 *    对象的状态改变从外界看来就像是行为在改变
 * 3、解决问题的方法不同
 *    策略模式只是确保算法可以自由切换，但是什么时候用什么算法它决定不了；而状态模式对外暴露的是
 *    行为，状态模式封装了状态的变化而暴露了不同的行为或行为结果
 * 4、应用场景不同
 *    策略模式应用于算法必须是平行的场景中；状态模式应用于既有状态又有行为的场景中
 */
/** 攻城略地，直梯攻城？暗度陈仓？还是断粮待降？ */
public interface AbstractStrategy {
    public void attack();
}
class StraightStrategy implements AbstractStrategy{
    public void attack() {
        System.out.println("直接进攻");
    }
}
class SecretlyStrategy implements AbstractStrategy{
    public void attack() {
        System.out.println("暗度陈仓");
    }
}
class StarveStrategy implements AbstractStrategy{
    public void attack() {
        System.out.println("断粮待降");
    }
}

