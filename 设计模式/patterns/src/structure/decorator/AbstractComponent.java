package structure.decorator;

/**
 * 装饰模式的优点：
 * 1、装饰类和被装饰类解耦
 * 2、装饰模式是继承关系的一种替代方案
 * 3、装饰模式可以动态扩展一个实现类的功能
 * 装饰模式的缺点：多层装饰是比较复杂的，
 *    最内层出了问题最不好排查
 * 装饰模式的应用场景：
 * 1、需要扩展一个类的功能，或者给一个类增加附加功能
 * 2、需要动态的给一个对象增加功能，并且还能再动态撤销
 * 3、需要为一批兄弟类进行改装或加装功能，首选该模式
 * 装饰模式最佳实战：
 * 1、该模式是对继承的有力补充，使用继承会增加很多子类，
 *    灵活性差，不易维护。用该模式替代继承，可解决类膨胀
 *    问题。且继承是静态扩展，而该模式是动态扩展
 * 2、对父类的功能扩展比用该模式，因为修改了父类可能会
 *    影响到现有子类，而使用该模式则可避免
 */
/**
 * 装饰模式和代理模式
 * 1、装饰模式就是代理模式的一个特殊应用，两者的共同点是都具有相同的接口
 *    不同点是代理模式着重对代理过程的控制，而装饰模式则着重对类的功能
 *    进行加强或减弱
 * 2、代理模式和装饰模式的代码实现非常相似，特别是装饰模式省略抽象装饰角色后，
 *    两者的代码基本相同
 */
/**
 * 装饰模式和适配器模式
 * 1、装饰模式和适配器模式在通用类图上没有太多相似点，但是他们的功能有相似的地方：
 *    都是包装作用，通过委托方式实现其功能。不同点是：装饰模式包装的是自己的兄弟类，
 *    隶属于同一个家族，适配器模式则修饰非血缘关系类，把一个非本家族的对象伪装成本
 *    家族的对象。
 * 2、不同点：
 * 1）意图不同：
 *    装饰模式的意图是加强兑现的功能，而适配器模式关注的则是转化，它的主要意图是两个
 *    不同对象之间的转化
 * 2）施与对象不同：
 *    装饰模式装饰的对象是自己的同宗，也就是相同的接口或父类，只要在具有相同属性和行为
 *    的情况下，才能比较行为是加强还是减弱；适配器模式必须是两个不同的对象，因为它着重
 *    于转换，只有两个不同的对象才有转换的必要
 * 3）场景不同：
 *    装饰模式在任何时候都可以使用，只要是想增强类的功能；而适配器模式则是一个补救模式，
 *    一般出现在系统成熟或已经构建完毕的项目中，作为一个紧急处理手段采用
 * 4）扩展性不同：
 *    装饰模式很容易扩展，不想用就去掉，想用就加上。而适配器模式是在两个对象之间架起了一座
 *    沟通的桥梁，建立容易，去掉就比较困难了。
 */

/** 天龙八部之阿朱易容 */
public interface AbstractComponent {
    public void disguise(); //易容术
}
class AZhu implements AbstractComponent {
    public void disguise() {
        System.out.println("阿朱会易容术");
    }
}
